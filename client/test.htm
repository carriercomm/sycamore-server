<script type="text/javascript" src="json2.js"></script>
<script type="text/javascript" src="jquery.min.js"></script>
<script type="text/javascript" src="socket.io.js"></script>
<script type="text/javascript">

io.setPath('./');


function serverConnection(config){

	var self = this;

	this.config = config;
	this.online = false;
	this.pingTimer = null;
	this.giveupTimer = null;
	this.lastConnected = 0;
	this.eventHandlers = {};

	this.socket = new io.Socket(config.host, {
		port: config.port
		//transports: ['xhr-polling']
	});


	//
	// set up the socket object
	//

	this.socket.on('connect', function(){

		self.lastConnected = new Date().getTime();

		self.emit('connected');
		self.emit('state', 'connected');
	});

	this.socket.on('close', function(){
		//console.log('closed');
	});

	this.socket.on('disconnect', function(){

		self.emit('disconnected');
		self.emit('state', 'disconnected');

		// if we get disconnected, we will immediately
		// try to reconnect. if we went offline on purpose,
		// self.online will be false so reconnect() will
		// just no-op.

		self.reconnect();
	});

	this.socket.on('message', function(data){

		if (data.msg == 'pong'){
			if (!self.socket.connected) return;
			var diff = (new Date().getTime()) - data.t;
			if (diff < 0) diff = 0;
			self.emit('state', 'connected', diff);
			//console.log('lag: '+diff);
			return;
		}

		self.emit('message', data);
	});


	//
	// event handlers
	//

	this.on = function(ev, f){
		if (!self.eventHandlers[ev]){
			self.eventHandlers[ev] = [];
		}
		self.eventHandlers[ev].push(f);
	};

	this.emit = function(){
		var args = Array.prototype.slice.call(arguments);
		var ev = args.shift();
		if (self.eventHandlers[ev]){
			for (var i=0; i<self.eventHandlers[ev].length; i++){
				var f = self.eventHandlers[ev][i];
				f.apply(self, args);
			}
		}
	}


	//
	// the real guts
	//

	this.brace_for_failure = function(){

		// this timer is set up so that we can decide to just stop trying
		// after a certain period.

		if (self.giveupTimer) window.clearTimeout(self.giveupTimer);
		self.giveupTimer = window.setTimeout(function(){ self.giveup(); }, self.config.giveup_interval);
	}

	this.connect = function(){
		self.online = true;
		self.emit('state', 'connecting');

		self.brace_for_failure();
		self.socket.connect();
	}

	this.reconnect = function(){
		if (!self.online) return;
		self.emit('state', 'reconnecting');

		self.brace_for_failure();
		self.socket.connect();
	}

	this.giveup = function(){
		window.clearTimeout(self.giveupTimer);
		self.giveupTimer = null;
		if (self.socket.connected) return;

		self.emit('state', 'disconnected');
	}


	//
	// ping is a simple interval - if we're connected, send
	// a ping message. if not, do nothing
	//

	self.pingTimer = window.setInterval(function(){
		if (self.socket.connected){
			self.socket.send({msg: 'ping', t: new Date().getTime()});
		}
	}, self.config.ping_interval);


	//
	// toggle the client on and off
	//

	this.go_online = function(){
		if (self.socket.connected) return;
		self.online = true;
		self.reconnect();
	}

	this.go_offline = function(){
		self.online = false;
		if (self.socket.connected) self.socket.disconnect();
	}


	//
	// send a message
	//

	this.send = function(msg){
		self.socket.send(msg);
	};


	// delay this call so that the caller can set up event handlers
	window.setTimeout(function(){ self.connect(); }, 0);
}

var con;

$(document).ready(function(){

	init_tiles();
	return;

	con = new serverConnection({
		host		: 'iamcal.com',
		port		: 8080,
		ping_interval	: 3000,
		giveup_interval	: 10000
	});

	con.on('state', function(state, lag){
		switch (state){
			case 'connected':
				$('#con').addClass('online').removeClass('offline');
				$('#lag').text(lag ? lag+'ms' : 'Connected');
				break;

			case 'disconnected':
				$('#con').removeClass('online').addClass('offline');
				$('#lag').text('Disconnected');
				break;

			case 'connecting':
				$('#con').removeClass('online').removeClass('offline');
				$('#lag').text('Connecting...');
				break;

			case 'reconnecting':
				$('#con').removeClass('online').removeClass('offline');
				$('#lag').text('Reconnecting...');
				break;

			default:
				$('#con').removeClass('online').removeClass('offline');
				$('#lag').text('Unknown: '+state);
		}
	});


	con.on('message', function(msg){

		switch (msg.msg){
			case 'welcome': return handleWelcome(msg);
			case 'joined': return handleJoined(msg);
			case 'left': return handleLeft(msg);
			case 'moved': return handleMoved(msg);
		}

		console.log('got a message!', msg);
	});

	con.on('connected', function(){

		//con.send({msg: 'some data'});
	});

	$('#playarea').click(function(e){
		var x = e.layerX;
		var y = e.layerY;
		con.send({msg: 'move', x:x, y:y});
	});
});

function handleWelcome(msg){
	$('#onlinelistplayers').html('');
	$('#playarea').html('');

	for (var i in msg.players){
		addPlayer(i, msg.players[i]);
	}
}

function addPlayer(uid, p){

	var txt = uid+": "+p.x+","+p.y;
	if (p.self) txt += " (you)";
	var d = $('<div>').text(txt);
	d.attr('id', 'players-'+uid);
	$('#onlinelistplayers').append(d);

	var dude = $('<div>').addClass('dude');
	dude.css({left: (p.x-7)+'px', top: (p.y-22)+'px'});
	dude.attr('id', 'players-dudes-'+uid);
	if (p.self) dude.css({backgroundColor: 'rgba(0,255,0,0.5)'});
	$('#playarea').append(dude);
}

function handleJoined(msg){
	addPlayer(msg.uid, msg.player);
}

function handleLeft(msg){
	$('#players-'+msg.uid).remove();
	$('#players-dudes-'+msg.uid).remove();
}

function handleMoved(msg){

	$('#players-dudes-'+msg.uid).css({left: (msg.x-7)+'px', top: (msg.y-22)+'px'});
}


function tileset(src, sz){

	var self = this;

	this.img = new Image();
	this.sz = sz;
	this.ready = false;
	this.onready = null;
	this.w = 1;
	this.h = 1;

	this.img.onload = function(){
		self.w = Math.floor(self.img.width / self.sz);
		self.h = Math.floor(self.img.height / self.sz);
		self.ready = true;
		if (self.onready) self.onready();
	};

	this.img.src = src;

	this.blt = function(ctx, tile_id, x, y){

		var sx = tile_id % self.w;
		var sy = Math.floor(tile_id / self.w);

		ctx.drawImage(self.img, sx * self.sz, sy * self.sz, self.sz, self.sz, x, y, self.sz, self.sz);
	};	
}

function gameMap(grid, tileset){

	var self = this;

	this.grid = grid;
	this.tileset = tileset;


	//
	// find the size of the map in tiles
	//

	this.tw = 0;
	this.th = grid.length;

	for (var y=0; y<this.th; y++){
		if (grid[y].length > this.tw) this.tw = grid[y].length;
	}


	//
	// now we have the real size, so create the buffer
	//

	this.w = this.tw * tileset.sz;
	this.h = this.th * tileset.sz;
	this.buffer = document.createElement('canvas');
	this.buffer.width = this.w;
	this.buffer.height = this.h;


	//
	// paint the map onto the buffer
	//

	var ctx = this.buffer.getContext("2d");

	for (var y=0; y<grid.length; y++){
	for (var x=0; x<grid[y].length; x++){

		tileset.blt(ctx, grid[y][x], x * tileset.sz, y * tileset.sz);
	}
	}
}

function tilesetPreview(tileset, cols, spacing){

	var num = tileset.w * tileset.h;
	var rows = Math.ceil(num / cols);

	this.buffer = document.createElement('canvas');
	this.buffer.width = cols * tileset.sz;
	this.buffer.height = rows * tileset.sz;

	var ctx = this.buffer.getContext("2d");

	for (var i=0; i<num; i++){
		var col = i % cols;
		var row = Math.floor(i / cols);

		tileset.blt(ctx, i, col * (tileset.sz + spacing), row * (tileset.sz + spacing));
	}
}


var t;

function init_tiles(){

	var map_data = [
		[13,21,21,21,21,21,21,13,13,13,14, 9, 9, 9, 9, 9, 9],
		[14, 9,51,52,10, 9,10,11,13,13,14, 9, 7, 8, 0, 1, 9],
		[14,10,53,54, 9,10, 9,11,13,13,14, 9,23,24,17,18, 9],
		[14, 9,10, 9,10, 9,10,11,13,13,14, 9,33,34,29,30, 9],
		[13, 3, 6,10, 9, 2, 3,13,13,13,14, 9,39,40,35,36, 9],
		[13,13,13, 3, 3,13,13,13,13,13,14, 9, 9, 9, 9, 9, 9],
		[13,21,21,21,21],
		[14,42,15,15,16],
		[14,43,44,45,28],
		[14,75,26,26,72]
	];

	t = new tileset('pink_big.png', 16);
	t.onready = function(){

		var map1 = new gameMap(map_data, t);
		var ts1 = new tilesetPreview(t, 10, 2);


		var ctx2 = document.getElementById('playarea2').getContext("2d");
		ctx2.drawImage(map1.buffer, 40, 180);
		ctx2.drawImage(ts1.buffer, 2, 2);
	}



	$('#playarea2').click(function(e){

		var x;
		var y;
		if (e.pageX || e.pageY){
			x = e.pageX;
			y = e.pageY;
		}else{
			x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
			y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
		}

		var offset = $(this).offset();

		x -= offset.left;
		y -= offset.top;

		con.send({msg: 'move', x:x, y:y});
	});
}

</script>
<style>

body {
	font-family: Arial, Helvetica, sans-serif;
}

#statusbar {
	position: absolute;
	top: 0px;
	left: 20px;
	right: 20px;
	height: 20px;
	padding: 6px 20px;

	-moz-border-radius-bottomleft: 10px;
	-moz-border-radius-bottomright: 10px;
	border-bottom-left-radius: 10px;
	border-bottom-right-radius: 10px;

	border-left: 1px solid #C7C7C7;
	border-right: 1px solid #C7C7C7;
	border-bottom: 1px solid #C7C7C7;

	background-color: #fff;
	background-image: -moz-linear-gradient(center bottom, rgb(233,233,233) 0%, rgb(255,255,255) 100%);
	background-image: -webkit-gradient(linear, left bottom, left top, color-stop(1, rgb(233,233,233)), color-stop(0, rgb(255,255,255)));

	-moz-box-shadow:	inset 0 0 15px 1px rgba(255,255,255, 0.5), 0 1px 3px #999;
	-webkit-box-shadow:	inset 0 0 15px 1px rgba(255,255,255, 0.5), 0 1px 3px #999;
	box-shadow:		inset 0 0 15px 1px rgba(255,255,255, 0.5), 0 1px 3px #999;
}

#constatus {
	float: right;
	line-height: 20px;
	font-size: 12px;
	text-shadow: #fff 1px 1px;
}

#con {
	width: 16px;
	height: 16px;
	border: 1px solid #000;
	background-color: red;
	margin-right: 8px;
	float: left;
}
#con.online { background-color: lime; }
#con.offline { background-color: #999; }

#onlinelist {
	position: absolute;
	left: 30px;
	top: 100px;
	border: 1px solid #666;
	background-color: #f5f5f5;
	padding: 1em;
}

#playarea {
	position: absolute;
	left: 400px;
	top: 100px;
	width: 400px;
	height: 400px;
	border: 1px solid #666;
	background-color: #f5f5f5;
}

#playarea2 {
	position: absolute;
	left: 820px;
	top: 100px;
	width: 400px;
	height: 400px;
	border: 1px solid #666;
	background-color: #f5f5f5;
}

.dude {
	position: absolute;
	width: 15px;
	height: 22px;
	background-image: url(bunny.gif);
}

</style>

<div id="statusbar">
	<div id="constatus">
		<div id="con"></div>
		<span id="lag">Disconnected</span>
	</div>
</div>

<div id="onlinelist">
	<b>Players Online</b><br />
	<div id="onlinelistplayers"></div>
</div>

<div id="playarea">
</div>

<canvas id="playarea2" width="400" height="400"></canvas>